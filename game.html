<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="description" content="Storage Snakes vs Flash Ladders"/>
  <title>Storage Snakes vs Flash Ladders</title>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&family=Poppins:wght@500;600&family=Roboto:wght@400;500&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="styles.css" />
  <style>
    /* Scoped styles for the game board */
    .game-wrapper { max-width: 1000px; margin: 80px auto; padding: 1rem; }
    .game-header { text-align: center; margin-bottom: 1rem; }
    .board {
      position: relative;
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      grid-auto-rows: 1fr;
      gap: 0;
      /* Use the supplied board artwork as the visual layout */
      background: url('./Flash snakes and ladders (2).png') center/100% 100% no-repeat;
      aspect-ratio: 1 / 1;
      width: 100%;
      max-width: 720px;
      margin: 0 auto;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      background-color: transparent;
    }
    .game-area { display: flex; gap: 1rem; align-items: flex-start; justify-content: center; }
    .dice-panel { width: 220px; min-width: 200px; display: flex; flex-direction: column; gap: 0.75rem; align-items: center; }
    .dice-box { display: flex; flex-direction: column; gap: 0.5rem; align-items: center; }
    .dice {
      width: 96px; height: 96px; background: #fff; border-radius: 12px;
      border: 3px solid #333; position: relative; box-shadow: 0 4px 10px rgba(0,0,0,0.15);
      display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);
      padding: 8px; box-sizing: border-box;
    }
    .pip { width: 16px; height: 16px; background: #333; border-radius: 50%; justify-self: center; align-self: center; }
    /* Position pips in 3x3 grid */
    .pip[data-pos="1"] { grid-row: 1; grid-column: 1; }
    .pip[data-pos="2"] { grid-row: 1; grid-column: 2; }
    .pip[data-pos="3"] { grid-row: 1; grid-column: 3; }
    .pip[data-pos="4"] { grid-row: 2; grid-column: 1; }
    .pip[data-pos="5"] { grid-row: 2; grid-column: 2; }
    .pip[data-pos="6"] { grid-row: 2; grid-column: 3; }
    .pip[data-pos="7"] { grid-row: 3; grid-column: 1; }
    .pip[data-pos="8"] { grid-row: 3; grid-column: 2; }
    .pip[data-pos="9"] { grid-row: 3; grid-column: 3; }
    .dice.rolling { animation: shake 0.6s infinite; }
    @keyframes shake { 0% { transform: rotate(0deg); } 25% { transform: rotate(8deg); } 50% { transform: rotate(0deg); } 75% { transform: rotate(-8deg); } 100% { transform: rotate(0deg); } }
    .dice-caption { font-weight: 600; }
    @media (max-width: 900px) { .game-area { flex-direction: column; align-items: center; } .dice-panel { width: auto; min-width: 0; } }
    .cell {
      position: relative;
      background: transparent;
      border-radius: 0;
      display: block;
    }
    .cell .num { position: absolute; top: 6px; left: 8px; font-size: 0.75rem; opacity: 0.35; color: #000; }
    /* Prevent overlay coloring so the artwork remains visible */
    .cell.snake { background: transparent; }
    .cell.ladder { background: transparent; }
    .cell.link-start { outline: 2px solid #e74c3c; }
    .cell.link-end { outline: 2px solid #27ae60; }

    .hud { 
      display: flex; flex-wrap: wrap; align-items: center; justify-content: center; 
      gap: 0.75rem; margin: 0 0 1rem 0; 
    }
    .hud .status { min-width: 220px; text-align: center; }
    .dice-btn { 
      background: var(--primary-blue, #1b4b8b); color: #fff; border: none; 
      padding: 0.6rem 1rem; border-radius: 6px; cursor: pointer; 
      font-weight: 600; letter-spacing: 0.2px; 
    }
    .dice-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .legend { display: flex; gap: 1rem; justify-content: center; margin-bottom: 1rem; }
    .legend span { display: inline-flex; align-items: center; gap: 0.4rem; }
    .legend .swatch { width: 14px; height: 14px; border-radius: 3px; display: inline-block; }
    .legend .swatch.snake { background: #f6b3b3; }
    .legend .swatch.ladder { background: #a9daf3; }
    .controls { display: flex; gap: 0.75rem; justify-content: center; align-items: center; margin-bottom: 0.75rem; flex-wrap: wrap; }
    .controls label { font-weight: 600; }
    .select, .btn { padding: 0.4rem 0.6rem; border-radius: 6px; border: 1px solid #ccc; }
    .btn { background: var(--primary-blue, #1b4b8b); color: #fff; border: none; }
    .btn.secondary { background: #777; color: #fff; border: none; }
    .badge { display: inline-block; padding: 0.12rem 0.4rem; border-radius: 6px; background: #eee; font-size: 0.8rem; }

    .player-token {
      position: absolute; width: 26px; height: 26px; border-radius: 50%; 
      background: linear-gradient(145deg, #ffd166, #fca311); 
      border: 3px solid #111; box-shadow: 0 2px 6px rgba(0,0,0,0.35);
      display: flex; align-items: center; justify-content: center; 
      font-size: 0.9rem; font-weight: 700; color: #111; 
      transform: translate(-50%, -50%);
      transition: top 1.8s ease-in-out, left 1.8s ease-in-out;
      z-index: 999;
    }
    .announce { text-align: center; min-height: 1.4rem; margin-top: 0.5rem; color: var(--primary-blue, #1b4b8b); font-weight: 600; }
  </style>
</head>
<body>
  <a href="#main-content" class="skip-link">Skip to main content</a>
  <!-- Code was learnt from here https://www.w3schools.com/accessibility/accessibility_skip_links.php#:~:text=The%20skip%20link%20is%20a,to%20it%20with%20an%20anchor.&text=That's%20it. -->

  <header role="banner">
    <nav role="navigation" aria-label="Main navigation">
      <div class="logo">
        <img src="./logo.png" alt="IBM & Service Express Logo" width="40" height="40" />
        <h1>Stuart Wade & Evelyn Mark</h1>
      </div>
      <ul>
        <li><a href="index.html">Home</a></li>
      </ul>
    </nav>
  </header>

  <main id="main-content" role="main">
    <div class="game-wrapper" aria-live="polite">
      <div class="game-header">
        <h2>Snakes and Ladders</h2>
        <p>Roll the dice. First to 36 wins.</p>
      </div>
 
      <div class="hud" role="group" aria-label="Game controls">
        <div class="status" id="status" aria-live="polite">Position: 1</div>
        <div class="status" id="diceText" aria-live="polite">Last roll: -</div>
        <div class="status" id="rolls" aria-live="polite">Rolls: 0</div>
      </div>
 
      <div class="game-area">
        <div class="board" id="board" role="img" aria-label="Snakes and Ladders board 1 to 36"></div>
        <aside class="dice-panel" aria-label="Dice panel">
          <div class="dice-box">
            <div id="dice" class="dice" aria-live="polite" role="img" aria-label="Dice showing value">
              <!-- 3x3 grid of pips; visibility controlled by JS -->
              <div class="pip" data-pos="1" style="visibility:hidden"></div>
              <div class="pip" data-pos="2" style="visibility:hidden"></div>
              <div class="pip" data-pos="3" style="visibility:hidden"></div>
              <div class="pip" data-pos="4" style="visibility:hidden"></div>
              <div class="pip" data-pos="5" style="visibility:hidden"></div>
              <div class="pip" data-pos="6" style="visibility:hidden"></div>
              <div class="pip" data-pos="7" style="visibility:hidden"></div>
              <div class="pip" data-pos="8" style="visibility:hidden"></div>
              <div class="pip" data-pos="9" style="visibility:hidden"></div>
            </div>
            <div class="dice-caption" id="diceCaption">Ready</div>
            <button id="rollBtn" class="dice-btn" aria-label="Roll the dice">Roll Dice</button>
            <button id="restartBtn" class="dice-btn" aria-label="Restart game">Start Again</button>
          </div>
        </aside>
      </div>
      <div class="announce" id="announce" aria-live="assertive"></div>
    </div>
  </main>
<!-- Footer Section -->
  <footer role="contentinfo">
    <div class="footer-content">
      <div class="footer-section">
        <h3>About Us</h3>
        <p>Stuart and I were introduced by Maria in September, and since then we’ve been brainstorming ways to showcase the fun side of storage. Here’s one idea - with more to come, so stay tuned!</p>
      </div>
      <div class="footer-section">
        <h3>Quick Links</h3>
        <ul>
          <li><a href="index.html">Home</a></li>
        </ul>
      </div>
    </div>
  </footer>
  <script>
    (function() {
      const boardEl = document.getElementById('board');
      const statusEl = document.getElementById('status');
      const diceEl = document.getElementById('dice');
      const diceCaptionEl = document.getElementById('diceCaption');
      const diceTextEl = document.getElementById('diceText');
      const rollsEl = document.getElementById('rolls');
      const rollBtn = document.getElementById('rollBtn');
      const restartBtn = document.getElementById('restartBtn');
      const announceEl = document.getElementById('announce');
 
      const boardSize = 6; // 6x6
      const lastCell = 36;
      const cells = [];
      const links = { 6: 18, 12: 24, 15: 27, 11: 3, 20: 16, 25: 23, 32: 28 }; // ladders and snakes
      let rollCount = 0;

      const boardInset = { top: 4, right: 2.5, bottom: 2, left: 2.5 }; 
 
      // Compute number for a visual row/col with fixed bottom-left serpentine
      function computeNumber(vRow, vCol) {
        const rFromBottom = boardSize - vRow + 1; // 1 at bottom row
        const odd = rFromBottom % 2 === 1;
        const indexInRow = odd ? vCol : (boardSize - vCol + 1);
        return (rFromBottom - 1) * boardSize + indexInRow;
      }
 
      // Build serpentine numbering layout 1..36
      function buildBoard() {
        boardEl.innerHTML = '';
        const frag = document.createDocumentFragment();
        for (let vRow = 1; vRow <= boardSize; vRow++) {
          for (let vCol = 1; vCol <= boardSize; vCol++) {
            const number = computeNumber(vRow, vCol);
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.setAttribute('data-cell', String(number));
            const num = document.createElement('span');
            num.className = 'num';
            num.textContent = String(number);
            cell.appendChild(num);
            frag.appendChild(cell);
            cells[number] = cell;
          }
        }
        boardEl.appendChild(frag);
      }

      // no edit/link UI; links remains empty by default

      function getVisualCoordsForNumber(num) {
        for (let vRow = 1; vRow <= boardSize; vRow++) {
          for (let vCol = 1; vCol <= boardSize; vCol++) {
            if (computeNumber(vRow, vCol) === num) {
              return { vRow, vCol };
            }
          }
        }
        return null;
      }

      function placeTokenAt(cellNumber) {
        const coords = getVisualCoordsForNumber(cellNumber);
        if (!coords) return;
        if (!tokenEl.parentElement) boardEl.appendChild(tokenEl);
        const topPercent = ((coords.vRow - 0.5) / boardSize) * 100;
        const leftPercent = ((coords.vCol - 0.5) / boardSize) * 100;
        tokenEl.style.top = topPercent + '%';
        tokenEl.style.left = leftPercent + '%';
        tokenEl.style.transform = 'translate(-50%, -50%)';
        void tokenEl.offsetWidth;
      }

      // Robust placement that waits for layout if needed
      // Removed safe wrapper; direct placement works with this layout

      // Dice rendering helpers
      const faceToPips = {
        1: [5],
        2: [1,9],
        3: [1,5,9],
        4: [1,3,7,9],
        5: [1,3,5,7,9],
        6: [1,3,4,6,7,9]
      };
      function renderDice(value) {
        const pips = diceEl.querySelectorAll('.pip');
        pips.forEach(p => p.style.visibility = 'hidden');
        (faceToPips[value] || []).forEach(pos => {
          const pip = diceEl.querySelector(`.pip[data-pos="${pos}"]`);
          if (pip) pip.style.visibility = 'visible';
        });
        diceEl.setAttribute('aria-label', 'Dice showing ' + value);
        diceCaptionEl.textContent = 'Rolled: ' + value;
        diceTextEl.textContent = 'Last roll: ' + value;
      }
      function randomDiceValue() { return Math.floor(Math.random() * 6) + 1; }
      function animateDiceRoll(finalValue) {
        return new Promise(resolve => {
          let ticks = 10;
          diceEl.classList.add('rolling');
          const interval = setInterval(() => {
            const v = randomDiceValue();
            renderDice(v);
            ticks--;
            if (ticks <= 0) {
              clearInterval(interval);
              diceEl.classList.remove('rolling');
              renderDice(finalValue);
              resolve();
            }
          }, 60);
        });
      }

      let position = 1;
      buildBoard();
      const tokenEl = document.createElement('div');
      tokenEl.className = 'player-token';
      tokenEl.setAttribute('aria-label', 'Player token');
      tokenEl.textContent = 'P';
      boardEl.appendChild(tokenEl);
      placeTokenAt(position);

      // links already defined (empty)

      function updateStatus(lastRoll) {
        statusEl.textContent = 'Position: ' + position;
        if (typeof lastRoll === 'number') diceTextEl.textContent = 'Last roll: ' + lastRoll;
        if (rollsEl) rollsEl.textContent = 'Rolls: ' + rollCount;
      }

      async function glideMove(from, to, delayMs) {
        const step = from < to ? 1 : -1;
        let current = from;
        while (current !== to) {
          current += step;
          placeTokenAt(current);
          await new Promise(r => setTimeout(r, delayMs));
        }
      }

      async function handleRoll() {
         if (handleRoll.rolling) return;
         handleRoll.rolling = true;
         rollBtn.disabled = true;
         announceEl.textContent = '';
         try {
           // ensure token is attached and positioned before starting
           placeTokenAt(position);
           const roll = randomDiceValue();
           await animateDiceRoll(roll);
           rollCount += 1;
 
           let target = position + roll;
           if (target > lastCell) {
             // must land exactly; ignore movement if overshoot
             announceEl.textContent = 'You must roll exactly ' + (lastCell - position) + ' to win!';
             updateStatus(roll);
             return;
           }
 
           // Wait 5 seconds after the dice roll before moving the token with visible countdown
           let remaining = 2;
           announceEl.textContent = 'Moving in ' + remaining + '…';
           await new Promise(resolve => {
             const timer = setInterval(() => {
               remaining -= 1;
               if (remaining <= 0) {
                 clearInterval(timer);
                 announceEl.textContent = 'Moving…';
                 resolve();
               } else {
                 announceEl.textContent = 'Moving in ' + remaining + '…';
               }
             }, 1000);
           });
 
           // Animated step-by-step movement with a slower glide (time-based)
           await glideMove(position, target, 1000);
           placeTokenAt(target);
           position = target;
           updateStatus(roll);
           placeTokenAt(position);
 
           // Check snake/ladder
           if (links[position]) {
             const dest = links[position];
             announceEl.textContent = dest > position ? 'Ladder! Climb to ' + dest : 'Snake! Slide to ' + dest;
            await glideMove(position, dest, 1000);
            placeTokenAt(dest);
            position = dest;
            updateStatus();
            placeTokenAt(position);
           }
 
           if (position === lastCell) {
             announceEl.textContent = 'You reached FINISH in ' + rollCount + ' rolls! You win!';
             return; // keep disabled
           }
         } catch (err) {
           console.error('Roll error', err);
         } finally {
           handleRoll.rolling = false;
           if (position !== lastCell) rollBtn.disabled = false;
         }
       }

      rollBtn.addEventListener('click', handleRoll);
      restartBtn.addEventListener('click', () => {
        position = 1;
        placeTokenAt(position);
        updateStatus();
        announceEl.textContent = 'Game reset. Roll to start!';
        rollBtn.disabled = false;
        diceCaptionEl.textContent = 'Ready';
        diceTextEl.textContent = 'Last roll: -';
        renderDice(1);
        rollCount = 0;
        updateStatus();
      });
      // Initialize dice face on load
      renderDice(1);
    })();
  </script>
</body>
</html>


